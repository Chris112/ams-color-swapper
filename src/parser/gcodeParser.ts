import fs from 'fs';
import readline from 'readline';
import { GcodeStats, ToolChange, ColorInfo } from '../types';
import { Logger } from '../debug/logger';
import { calculateStatistics } from './statistics';

export class GcodeParser {
  private logger: Logger;
  private stats: Partial<GcodeStats>;
  private currentLayer: number = 0;
  private currentZ: number = 0;
  private currentTool: string = 'T0';
  private toolChanges: ToolChange[] = [];
  private layerColorMap: Map<number, string> = new Map();
  private colorFirstSeen: Map<string, number> = new Map();
  private colorLastSeen: Map<string, number> = new Map();
  private lineNumber: number = 0;
  private startTime: number = 0;

  constructor(logger?: Logger) {
    this.logger = logger || new Logger();
    this.stats = {
      toolChanges: [],
      layerColorMap: new Map(),
      parserWarnings: [],
      colors: []
    };
  }

  async parse(filePath: string, fileName: string): Promise<GcodeStats> {
    this.startTime = Date.now();
    this.logger.info(`Starting G-code parse for ${fileName}`);

    const fileStats = await fs.promises.stat(filePath);
    this.stats.fileName = fileName;
    this.stats.fileSize = fileStats.size;

    // Initialize layer 0 with the default tool
    this.layerColorMap.set(0, this.currentTool);
    this.updateColorSeen(this.currentTool, 0);

    const fileStream = fs.createReadStream(filePath);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    await this.processLines(rl);
    
    const parseTime = Date.now() - this.startTime;
    this.logger.info(`Parse completed in ${parseTime}ms`);

    const completeStats = await calculateStatistics(
      this.stats as GcodeStats,
      this.toolChanges,
      this.layerColorMap,
      this.colorFirstSeen,
      this.colorLastSeen,
      parseTime
    );

    return completeStats;
  }

  private async processLines(rl: readline.Interface): Promise<void> {
    for await (const line of rl) {
      this.lineNumber++;
      await this.parseLine(line.trim());
    }
  }

  private async parseLine(line: string): Promise<void> {
    if (!line || line.startsWith(';')) {
      this.parseComment(line);
      return;
    }

    const command = line.split(' ')[0].toUpperCase();

    switch (command) {
      case 'G0':
      case 'G1':
        this.parseMove(line);
        break;
      case 'M600':
        this.parseFilamentChange(line);
        break;
      case 'T0':
      case 'T1':
      case 'T2':
      case 'T3':
      case 'T4':
      case 'T5':
      case 'T6':
      case 'T7':
        this.parseToolChange(command);
        break;
    }
  }

  private parseComment(line: string) {
    // Extract color definitions for Bambu Lab
    if (line.includes('extruder_colour') || line.includes('filament_colour')) {
      const colorMatch = line.match(/= (.+)/);
      if (colorMatch) {
        const colors = colorMatch[1].split(';');
        this.logger.info(`Found ${colors.length} color definitions`);
        // Store color info for later use
        if (!this.stats.slicerInfo) {
          this.stats.slicerInfo = { software: 'Unknown', version: 'Unknown' };
        }
        this.stats.slicerInfo.colorDefinitions = colors;
      }
    }
    
    if (line.includes('generated by')) {
      const slicerMatch = line.match(/generated by (.+?) ([\d.]+)/i);
      if (slicerMatch) {
        if (!this.stats.slicerInfo) {
          this.stats.slicerInfo = {
            software: slicerMatch[1],
            version: slicerMatch[2]
          };
        }
        this.logger.info(`Detected slicer: ${slicerMatch[1]} v${slicerMatch[2]}`);
      }
    }

    // Handle various layer formats
    let layerMatch = null;
    
    // Bambu Lab format: "; layer num/total_layer_count: 1/197"
    if (line.includes('layer num/total_layer_count:')) {
      layerMatch = line.match(/layer num\/total_layer_count:\s*(\d+)/);
    }
    // Bambu Lab format: "; layer #2"
    else if (line.includes('; layer #')) {
      layerMatch = line.match(/; layer #(\d+)/);
    }
    // Standard formats
    else if (line.includes('LAYER:') || line.includes('layer ')) {
      layerMatch = line.match(/(?:LAYER:|layer )\s*(\d+)/i);
    }
    
    if (layerMatch) {
      const newLayer = parseInt(layerMatch[1]);
      if (newLayer !== this.currentLayer) {
        this.currentLayer = newLayer;
        this.layerColorMap.set(this.currentLayer, this.currentTool);
        this.updateColorSeen(this.currentTool, this.currentLayer);
        this.logger.debug(`Layer ${this.currentLayer} - Tool: ${this.currentTool}`);
      }
    }

    if (line.includes('filament used')) {
      const filamentMatch = line.match(/filament used.*?(\d+\.?\d*)\s*mm/i);
      if (filamentMatch) {
        const length = parseFloat(filamentMatch[1]);
        if (!this.stats.filamentEstimates) {
          this.stats.filamentEstimates = [];
        }
        this.stats.filamentEstimates.push({
          colorId: this.currentTool,
          length
        });
      }
    }

    if (line.includes('estimated printing time')) {
      const timeMatch = line.match(/(\d+)h\s*(\d+)m\s*(\d+)s/);
      if (timeMatch) {
        const hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const seconds = parseInt(timeMatch[3]);
        this.stats.estimatedPrintTime = hours * 3600 + minutes * 60 + seconds;
        this.logger.info(`Estimated print time: ${hours}h ${minutes}m ${seconds}s`);
      }
    }
  }

  private parseMove(line: string) {
    const zMatch = line.match(/Z([\d.]+)/);
    if (zMatch) {
      const newZ = parseFloat(zMatch[1]);
      if (newZ > this.currentZ) {
        this.currentZ = newZ;
        if (!this.stats.totalHeight || newZ > this.stats.totalHeight) {
          this.stats.totalHeight = newZ;
        }
      }
    }
  }

  private parseFilamentChange(_line: string) {
    this.logger.warn(`Manual filament change detected at layer ${this.currentLayer}, line ${this.lineNumber}`);
    this.stats.parserWarnings?.push(
      `M600 filament change at layer ${this.currentLayer} (line ${this.lineNumber})`
    );
  }

  private parseToolChange(tool: string) {
    if (tool !== this.currentTool) {
      const change: ToolChange = {
        fromTool: this.currentTool,
        toTool: tool,
        layer: this.currentLayer,
        lineNumber: this.lineNumber,
        zHeight: this.currentZ
      };
      
      this.toolChanges.push(change);
      this.logger.info(`Tool change: ${this.currentTool} â†’ ${tool} at layer ${this.currentLayer}`);
      
      this.currentTool = tool;
      // Don't update the layer color map here - wait for the layer change
      // This ensures we track which tool is active when the layer actually starts printing
    }
  }

  private updateColorSeen(tool: string, layer: number) {
    if (!this.colorFirstSeen.has(tool)) {
      this.colorFirstSeen.set(tool, layer);
    }
    this.colorLastSeen.set(tool, layer);
  }
}