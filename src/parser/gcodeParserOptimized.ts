import { GcodeStats, ToolChange } from '../types';
import { Logger } from '../utils/logger';
import { BrowserFileReader } from '../utils/fileReader';
import { calculateStatistics } from './statistics';

// Pre-compiled regex patterns for better performance
const REGEX_PATTERNS = {
  // Tool patterns
  TOOL: /^T([0-7])$/,

  // Move patterns
  Z_COORD: /Z([\d.]+)/,

  // Layer patterns
  LAYER_NUM_TOTAL: /layer num\/total_layer_count:\s*(\d+)/,
  LAYER_HASH: /; layer #(\d+)/,
  LAYER_GENERIC: /(?:LAYER:|layer )\s*(\d+)/i,

  // Time patterns
  TIME_TOTAL: /total estimated time:\s*(\d+)h\s*(\d+)m\s*(\d+)s/,
  TIME_ESTIMATED: /(\d+)h\s*(\d+)m\s*(\d+)s/,

  // Filament patterns
  FILAMENT_COST: /filament cost = (.+)/,
  FILAMENT_WEIGHT: /filament used \[g\] = (.+)/,
  FILAMENT_DETAIL: /filament used \[g\] = ([\d.]+) \(([\d.]+)\+([\d.]+)\)/,
  FILAMENT_MM: /filament used.*?(\d+\.?\d*)\s*mm/i,

  // Material patterns
  FLUSHED_MATERIAL: /flushed material = ([\d.]+)/,
  WIPE_TOWER: /wipe tower = ([\d.]+)/,

  // Color patterns
  COLOR_DEF: /(?:extruder_colour|filament_colour).*?= (.+)/,

  // Slicer info
  SLICER_INFO: /generated by (.+?) ([\d.]+)/i,
};

export class GcodeParserOptimized {
  private logger: Logger;
  private stats: Partial<GcodeStats>;
  private currentLayer: number = 0;
  private currentZ: number = 0;
  private currentTool: string = 'T0';
  private toolChanges: ToolChange[] = [];
  private layerColorMap: Map<number, string> = new Map();
  private colorFirstSeen: Map<string, number> = new Map();
  private colorLastSeen: Map<string, number> = new Map();
  private lineNumber: number = 0;
  private startTime: number = 0;
  private onProgress?: (progress: number, message: string) => void;
  private rawContent: string = '';

  constructor(logger?: Logger, onProgress?: (progress: number, message: string) => void) {
    this.logger = logger || new Logger('GcodeParser');
    this.onProgress = onProgress;
    this.stats = {
      toolChanges: [],
      layerColorMap: new Map(),
      parserWarnings: [],
      colors: [],
    };
  }

  async parse(file: File): Promise<GcodeStats> {
    // Reset all state for new parse
    this.currentLayer = 0;
    this.currentZ = 0;
    this.currentTool = 'T0';
    this.toolChanges = [];
    this.layerColorMap = new Map();
    this.colorFirstSeen = new Map();
    this.colorLastSeen = new Map();
    this.lineNumber = 0;
    this.rawContent = '';
    this.stats = {
      toolChanges: [],
      layerColorMap: new Map(),
      parserWarnings: [],
      colors: [],
    };

    this.startTime = Date.now();
    this.logger.info(`Starting G-code parse for ${file.name}`);

    if (this.onProgress) {
      this.onProgress(5, 'Reading file...');
    }

    this.stats.fileName = file.name;
    this.stats.fileSize = file.size;
    this.stats.totalLayers = 1;
    this.stats.totalHeight = 0;

    // Initialize layer 0 with the default tool
    this.layerColorMap.set(0, this.currentTool);
    this.updateColorSeen(this.currentTool, 0);

    // Estimate total lines for progress tracking
    if (this.onProgress) {
      this.onProgress(10, 'Estimating file size...');
    }
    const estimatedLines = Math.ceil(file.size / 24);
    this.logger.info(
      `Estimated lines to process: ${estimatedLines.toLocaleString()} (based on ${file.size.toLocaleString()} bytes)`
    );

    // Create reader from the original file
    const reader = new BrowserFileReader(file);

    if (this.onProgress) {
      this.onProgress(20, 'Parsing G-code...');
    }
    await this.processLines(reader, estimatedLines);

    const parseTime = Date.now() - this.startTime;
    this.logger.info(`Parse completed in ${parseTime}ms`);

    if (this.onProgress) {
      this.onProgress(85, 'Analyzing colors and calculating statistics...');
    }

    // Store the raw content we built during parsing
    this.stats.rawContent = this.rawContent;

    const completeStats = await calculateStatistics(
      this.stats as GcodeStats,
      this.toolChanges,
      this.layerColorMap,
      this.colorFirstSeen,
      this.colorLastSeen,
      parseTime
    );

    if (this.onProgress) {
      this.onProgress(95, 'Finalizing analysis...');
    }

    // Ensure we have at least basic data
    if (!completeStats.colors || completeStats.colors.length === 0) {
      completeStats.colors = [
        {
          id: 'T0',
          name: 'Default Color',
          hexColor: '#888888',
          firstLayer: 0,
          lastLayer: completeStats.totalLayers - 1,
          layerCount: completeStats.totalLayers,
          usagePercentage: 100,
        },
      ];
    }

    // Log analysis summary
    this.logger.info('G-code Analysis Summary', {
      fileName: file.name,
      parseTime: `${parseTime}ms`,
      totalLayers: completeStats.totalLayers,
      totalHeight: `${completeStats.totalHeight}mm`,
      uniqueColors: completeStats.colors.length,
      toolChanges: completeStats.toolChanges?.length || 0,
      filamentUsage: completeStats.filamentUsageStats?.total
        ? `${completeStats.filamentUsageStats.total.toFixed(2)}mm`
        : 'N/A',
      printTime: completeStats.printTime || 'N/A',
    });

    // Log color details
    completeStats.colors.forEach((color, index) => {
      this.logger.info(`Color ${index + 1}`, {
        id: color.id,
        name: color.name,
        hex: color.hexColor,
        usage: `${color.usagePercentage?.toFixed(2)}%`,
        layers: `${color.firstLayer}-${color.lastLayer}`,
        layerCount: color.layerCount,
      });
    });

    // Log optimization potential
    if (completeStats.colors.length > 4) {
      this.logger.info(
        `Optimization needed: ${completeStats.colors.length} colors detected, but AMS only has 4 slots`
      );
    }

    return completeStats;
  }

  private async processLines(reader: BrowserFileReader, totalLines: number): Promise<void> {
    // Update progress every 5% instead of 1%
    const progressInterval = Math.max(Math.floor(totalLines / 20), 5000);

    for await (const line of reader.readLines()) {
      this.lineNumber++;

      // Store raw content during parsing (eliminates second read)
      this.rawContent += line + '\n';

      await this.parseLine(line.trim());

      // Report progress less frequently
      if (this.onProgress && this.lineNumber % progressInterval === 0) {
        const progressPercent = (this.lineNumber / totalLines) * 60;
        const totalProgress = Math.min(20 + progressPercent, 80);
        const percentage = Math.round((this.lineNumber / totalLines) * 100);
        this.onProgress(totalProgress, `Processing: ${percentage}%`);
      }
    }

    // Final update after all lines processed
    if (this.onProgress) {
      this.onProgress(80, `Processed ${this.lineNumber.toLocaleString()} lines`);
    }
  }

  private async parseLine(line: string): Promise<void> {
    if (!line) return;

    // Early exit based on first character
    const firstChar = line[0];

    if (firstChar === ';') {
      // Comment line - most important data is here
      this.parseComment(line);
      return;
    }

    if (firstChar === 'T' && line.length === 2) {
      // Quick tool change check
      const tool = line[1];
      if (tool >= '0' && tool <= '7') {
        this.parseToolChange(line);
        return;
      }
    }

    if (firstChar === 'G') {
      // G-code command
      const secondChar = line[1];
      if (secondChar === '0' || secondChar === '1') {
        this.parseMove(line);
        return;
      }
    }

    if (firstChar === 'M' && line.startsWith('M600')) {
      this.parseFilamentChange(line);
      return;
    }
  }

  private parseComment(line: string) {
    // Use indexOf for simple patterns first
    if (line.includes('extruder_colour') || line.includes('filament_colour')) {
      const match = line.match(REGEX_PATTERNS.COLOR_DEF);
      if (match) {
        const colors = match[1].split(';');
        this.logger.info(`Found ${colors.length} color definitions`);
        if (!this.stats.slicerInfo) {
          this.stats.slicerInfo = { software: 'Unknown', version: 'Unknown' };
        }
        this.stats.slicerInfo.colorDefinitions = colors;
      }
      return;
    }

    if (line.includes('generated by')) {
      const match = line.match(REGEX_PATTERNS.SLICER_INFO);
      if (match) {
        if (!this.stats.slicerInfo) {
          this.stats.slicerInfo = {
            software: match[1],
            version: match[2],
          };
        }
        this.logger.info(`Detected slicer: ${match[1]} v${match[2]}`);
      }
      return;
    }

    // Layer detection - check most common formats first
    if (line.includes('layer')) {
      let layerMatch = null;

      if (line.includes('layer num/total_layer_count:')) {
        layerMatch = line.match(REGEX_PATTERNS.LAYER_NUM_TOTAL);
      } else if (line.includes('; layer #')) {
        layerMatch = line.match(REGEX_PATTERNS.LAYER_HASH);
      } else {
        layerMatch = line.match(REGEX_PATTERNS.LAYER_GENERIC);
      }

      if (layerMatch) {
        const newLayer = parseInt(layerMatch[1]);
        if (newLayer !== this.currentLayer) {
          this.currentLayer = newLayer;
          this.layerColorMap.set(this.currentLayer, this.currentTool);
          this.updateColorSeen(this.currentTool, this.currentLayer);
          this.logger.silly(`Layer ${this.currentLayer} - Tool: ${this.currentTool}`);
        }
      }
      return;
    }

    // Time extraction
    if (line.includes('total estimated time:')) {
      const match = line.match(REGEX_PATTERNS.TIME_TOTAL);
      if (match) {
        const hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        const seconds = parseInt(match[3]);
        this.stats.printTime = `${hours}h ${minutes}m ${seconds}s`;
        this.stats.estimatedPrintTime = hours * 3600 + minutes * 60 + seconds;
        this.logger.info(`Total estimated time: ${this.stats.printTime}`);
      }
      return;
    }

    // Filament cost
    if (line.includes('filament cost =')) {
      const match = line.match(REGEX_PATTERNS.FILAMENT_COST);
      if (match) {
        const costs = match[1].split(',').map((c) => parseFloat(c.trim()));
        const totalCost = costs.reduce((sum, cost) => sum + cost, 0);
        this.stats.printCost = Math.round(totalCost * 100) / 100;
        this.logger.info(`Print cost: $${this.stats.printCost}`);
      }
      return;
    }

    // Filament usage in grams
    if (line.includes('filament used [g]')) {
      const match = line.match(REGEX_PATTERNS.FILAMENT_WEIGHT);
      if (match) {
        const weights = match[1].split(',').map((w) => parseFloat(w.trim()));
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);

        if (!this.stats.filamentUsageStats) {
          this.stats.filamentUsageStats = {
            total: Math.round(totalWeight * 100) / 100,
            model: 0,
            support: 0,
            flushed: 0,
            tower: 0,
          };
        } else {
          this.stats.filamentUsageStats.total = Math.round(totalWeight * 100) / 100;
        }

        // Store per-color filament weights
        if (!this.stats.filamentEstimates) {
          this.stats.filamentEstimates = [];
        }

        weights.forEach((weight, index) => {
          if (weight > 0) {
            const toolId = `T${index}`;
            const existingEntry = this.stats.filamentEstimates!.find((e) => e.colorId === toolId);
            if (existingEntry) {
              existingEntry.weight = weight;
            } else {
              this.stats.filamentEstimates!.push({
                colorId: toolId,
                length: 0,
                weight: weight,
              });
            }
          }
        });

        this.logger.info(`Total filament usage: ${this.stats.filamentUsageStats.total}g`);
        this.logger.info(`Per-color weights: ${weights.map((w, i) => `T${i}: ${w}g`).join(', ')}`);
      }
      return;
    }

    // Flushed material
    if (line.includes('flushed material =')) {
      const match = line.match(REGEX_PATTERNS.FLUSHED_MATERIAL);
      if (match) {
        if (!this.stats.filamentUsageStats) {
          this.stats.filamentUsageStats = {
            total: 0,
            model: 0,
            support: 0,
            flushed: 0,
            tower: 0,
          };
        }
        this.stats.filamentUsageStats.flushed = parseFloat(match[1]);
      }
      return;
    }

    // Wipe tower
    if (line.includes('wipe tower =')) {
      const match = line.match(REGEX_PATTERNS.WIPE_TOWER);
      if (match) {
        if (!this.stats.filamentUsageStats) {
          this.stats.filamentUsageStats = {
            total: 0,
            model: 0,
            support: 0,
            flushed: 0,
            tower: 0,
          };
        }
        this.stats.filamentUsageStats.tower = parseFloat(match[1]);
      }
      return;
    }
  }

  private parseMove(line: string) {
    const match = line.match(REGEX_PATTERNS.Z_COORD);
    if (match) {
      const newZ = parseFloat(match[1]);
      if (newZ > this.currentZ) {
        this.currentZ = newZ;
        if (!this.stats.totalHeight || newZ > this.stats.totalHeight) {
          this.stats.totalHeight = newZ;
        }
      }
    }
  }

  private parseFilamentChange(_line: string) {
    this.logger.warn(
      `Manual filament change detected at layer ${this.currentLayer}, line ${this.lineNumber}`
    );
    this.stats.parserWarnings?.push(
      `M600 filament change at layer ${this.currentLayer} (line ${this.lineNumber})`
    );
  }

  private parseToolChange(tool: string) {
    if (tool !== this.currentTool) {
      const change: ToolChange = {
        fromTool: this.currentTool,
        toTool: tool,
        layer: this.currentLayer,
        lineNumber: this.lineNumber,
        zHeight: this.currentZ,
      };

      this.toolChanges.push(change);
      this.logger.silly(`Tool change: ${this.currentTool} → ${tool} at layer ${this.currentLayer}`);

      this.currentTool = tool;
      // Update the layer color map for the current layer
      this.layerColorMap.set(this.currentLayer, this.currentTool);
      this.updateColorSeen(this.currentTool, this.currentLayer);
    }
  }

  private updateColorSeen(tool: string, layer: number) {
    if (!this.colorFirstSeen.has(tool)) {
      this.colorFirstSeen.set(tool, layer);
    }
    this.colorLastSeen.set(tool, layer);
  }
}
