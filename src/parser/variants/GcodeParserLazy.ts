import { GcodeStats, ToolChange } from '../../types';
import { Logger } from '../../utils/logger';
import { BrowserFileReader } from '../../utils/fileReader';
import { calculateStatistics } from '../statistics';

interface LazyParseResult {
  basicStats: {
    fileName: string;
    fileSize: number;
    totalLayers: number;
    uniqueTools: Set<string>;
    hasFilamentChanges: boolean;
  };
  getFullStats: () => Promise<GcodeStats>;
}

export class GcodeParserLazy {
  private logger: Logger;
  private onProgress?: (progress: number, message: string) => void;

  constructor(logger?: Logger, onProgress?: (progress: number, message: string) => void) {
    this.logger = logger || new Logger('GcodeParserLazy');
    this.onProgress = onProgress;
  }

  async parse(file: File): Promise<GcodeStats> {
    // For benchmark compatibility, we'll do the full parse
    // In a real implementation, this would return LazyParseResult
    const result = await this.lazyParse(file);
    return await result.getFullStats();
  }

  async lazyParse(file: File): Promise<LazyParseResult> {
    const startTime = Date.now();
    this.logger.info(`Starting lazy G-code parse for ${file.name}`);

    if (this.onProgress) {
      this.onProgress(5, 'Quick scan starting...');
    }

    // Basic info available immediately
    const basicStats = {
      fileName: file.name,
      fileSize: file.size,
      totalLayers: 0,
      uniqueTools: new Set<string>(['T0']),
      hasFilamentChanges: false,
    };

    // Quick scan - only look for essential info
    const quickScanResult = await this.quickScan(file);
    basicStats.totalLayers = quickScanResult.maxLayer + 1;
    basicStats.uniqueTools = quickScanResult.tools;
    basicStats.hasFilamentChanges = quickScanResult.hasM600;

    const quickScanTime = Date.now() - startTime;
    this.logger.info(`Quick scan completed in ${quickScanTime}ms`);

    if (this.onProgress) {
      this.onProgress(100, 'Quick scan complete!');
    }

    // Return lazy result with deferred full parsing
    return {
      basicStats,
      getFullStats: async () => {
        this.logger.info('Full parse requested, processing...');
        if (this.onProgress) {
          this.onProgress(0, 'Starting full analysis...');
        }
        return await this.fullParse(file, quickScanResult);
      },
    };
  }

  private async quickScan(file: File): Promise<{
    maxLayer: number;
    tools: Set<string>;
    hasM600: boolean;
    colorDefs?: string[];
    slicerInfo?: { software: string; version: string };
  }> {
    const reader = new BrowserFileReader(file);
    let maxLayer = 0;
    const tools = new Set<string>(['T0']);
    let hasM600 = false;
    let colorDefs: string[] | undefined;
    let slicerInfo: { software: string; version: string } | undefined;
    let linesScanned = 0;
    const maxLinesToScan = 10000; // Only scan first 10k lines for quick info

    for await (const line of reader.readLines()) {
      linesScanned++;
      
      // Stop after scanning enough lines
      if (linesScanned > maxLinesToScan) {
        this.logger.info(`Quick scan stopped after ${maxLinesToScan} lines`);
        break;
      }

      const trimmed = line.trim();

      // Skip empty lines
      if (!trimmed) continue;

      // Check for tool changes (quick check)
      if (trimmed[0] === 'T' && trimmed.length >= 2) {
        const secondChar = trimmed[1];
        if (secondChar >= '0' && secondChar <= '7') {
          tools.add(trimmed.substring(0, 2));
        }
      }

      // Check for M600
      else if (trimmed.startsWith('M600')) {
        hasM600 = true;
      }

      // Check comments for important info
      else if (trimmed[0] === ';') {
        // Layer detection
        if (trimmed.includes('layer')) {
          const layerMatch = trimmed.match(/layer\s*(?:#|num\/total_layer_count:)?\s*(\d+)/i);
          if (layerMatch) {
            const layer = parseInt(layerMatch[1]);
            if (layer > maxLayer) maxLayer = layer;
          }
        }

        // Color definitions
        else if ((trimmed.includes('extruder_colour') || trimmed.includes('filament_colour')) && !colorDefs) {
          const parts = trimmed.split('=');
          if (parts.length > 1) {
            colorDefs = parts[1].split(';');
          }
        }

        // Slicer info
        else if (trimmed.includes('generated by') && !slicerInfo) {
          const match = trimmed.match(/generated by\s+(.+?)\s+(.+)/);
          if (match) {
            slicerInfo = { software: match[1], version: match[2] };
          }
        }
      }

      // Progress update
      if (this.onProgress && linesScanned % 1000 === 0) {
        const progress = Math.min((linesScanned / maxLinesToScan) * 90, 90);
        this.onProgress(progress, `Quick scanning... ${linesScanned} lines`);
      }
    }

    return { maxLayer, tools, hasM600, colorDefs, slicerInfo };
  }

  private async fullParse(
    file: File,
    quickScanResult: {
      maxLayer: number;
      tools: Set<string>;
      hasM600: boolean;
      colorDefs?: string[];
      slicerInfo?: { software: string; version: string };
    }
  ): Promise<GcodeStats> {
    const startTime = Date.now();
    const stats: Partial<GcodeStats> = {
      fileName: file.name,
      fileSize: file.size,
      totalLayers: 1,
      totalHeight: 0,
      toolChanges: [],
      layerColorMap: new Map(),
      parserWarnings: [],
      colors: [],
      slicerInfo: quickScanResult.slicerInfo,
    };

    if (quickScanResult.slicerInfo && quickScanResult.colorDefs) {
      stats.slicerInfo!.colorDefinitions = quickScanResult.colorDefs;
    }

    let currentLayer = 0;
    let maxLayerSeen = 0;
    let currentZ = 0;
    let currentTool = 'T0';
    const toolChanges: ToolChange[] = [];
    const layerColorMap: Map<number, string> = new Map();
    const colorFirstSeen: Map<string, number> = new Map();
    const colorLastSeen: Map<string, number> = new Map();
    let lineNumber = 0;

    // Initialize
    layerColorMap.set(0, currentTool);
    colorFirstSeen.set(currentTool, 0);
    colorLastSeen.set(currentTool, 0);

    const reader = new BrowserFileReader(file);
    const estimatedLines = Math.ceil(file.size / 24);
    const progressInterval = Math.max(Math.floor(estimatedLines / 100), 1000);

    if (this.onProgress) {
      this.onProgress(20, 'Full parsing in progress...');
    }

    for await (const line of reader.readLines()) {
      lineNumber++;
      const trimmed = line.trim();

      if (!trimmed) continue;

      // Comments
      if (trimmed[0] === ';') {
        // Layer changes
        if (trimmed.includes('layer')) {
          const layerMatch = trimmed.match(/layer\s*(?:#|num\/total_layer_count:)?\s*(\d+)/i);
          if (layerMatch) {
            const newLayer = parseInt(layerMatch[1]);
            if (newLayer !== currentLayer) {
              currentLayer = newLayer;
              if (newLayer > maxLayerSeen) {
                maxLayerSeen = newLayer;
              }
              layerColorMap.set(currentLayer, currentTool);
              if (!colorFirstSeen.has(currentTool)) {
                colorFirstSeen.set(currentTool, currentLayer);
              }
              colorLastSeen.set(currentTool, currentLayer);
            }
          }
        }

        // Print time
        else if (trimmed.includes('estimated') && trimmed.includes('time')) {
          const timeMatch = trimmed.match(/(\d+)h\s*(\d+)m\s*(\d+)s/);
          if (timeMatch) {
            const hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            const seconds = parseInt(timeMatch[3]);
            stats.printTime = `${hours}h ${minutes}m ${seconds}s`;
            stats.estimatedPrintTime = hours * 3600 + minutes * 60 + seconds;
          }
        }

        // Filament usage
        else if (trimmed.includes('filament used [g]')) {
          const parts = trimmed.split('=');
          if (parts.length > 1) {
            const weights = parts[1].split(',').map((w) => parseFloat(w.trim()));
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);

            stats.filamentUsageStats = {
              total: Math.round(totalWeight * 100) / 100,
              model: 0,
              support: 0,
              flushed: 0,
              tower: 0,
            };

            stats.filamentEstimates = [];
            weights.forEach((weight, index) => {
              if (weight > 0) {
                stats.filamentEstimates!.push({
                  colorId: `T${index}`,
                  length: 0,
                  weight: weight,
                });
              }
            });
          }
        }
      }

      // Commands
      else {
        const command = trimmed.split(' ')[0].toUpperCase();

        // Move commands
        if (command === 'G0' || command === 'G1') {
          const zMatch = trimmed.match(/Z([-+]?\d*\.?\d+)/);
          if (zMatch) {
            const newZ = parseFloat(zMatch[1]);
            if (!isNaN(newZ) && newZ > currentZ) {
              currentZ = newZ;
              if (!stats.totalHeight || newZ > stats.totalHeight) {
                stats.totalHeight = newZ;
              }
            }
          }
        }

        // Tool changes
        else if (command.length === 2 && command[0] === 'T' && command[1] >= '0' && command[1] <= '7') {
          if (command !== currentTool) {
            toolChanges.push({
              fromTool: currentTool,
              toTool: command,
              layer: currentLayer,
              lineNumber: lineNumber,
              zHeight: currentZ,
            });
            currentTool = command;
          }
        }

        // Filament change
        else if (command === 'M600') {
          stats.parserWarnings?.push(
            `M600 filament change at layer ${currentLayer} (line ${lineNumber})`
          );
        }
      }

      // Progress
      if (this.onProgress && lineNumber % progressInterval === 0) {
        const progressPercent = (lineNumber / estimatedLines) * 60;
        const totalProgress = Math.min(20 + progressPercent, 80);
        this.onProgress(
          totalProgress,
          `Full parse: ${Math.round((lineNumber / estimatedLines) * 100)}%`
        );
      }
    }

    const parseTime = Date.now() - startTime;

    if (this.onProgress) {
      this.onProgress(85, 'Calculating statistics...');
    }

    // Set total layers based on maxLayerSeen
    stats.totalLayers = maxLayerSeen + 1;

    const completeStats = await calculateStatistics(
      stats as GcodeStats,
      toolChanges,
      layerColorMap,
      colorFirstSeen,
      colorLastSeen,
      parseTime
    );

    // Load raw content
    if (!stats.rawContent) {
      if (this.onProgress) {
        this.onProgress(90, 'Loading raw content...');
      }
      stats.rawContent = await file.text();
      completeStats.rawContent = stats.rawContent;
    }

    if (!completeStats.colors || completeStats.colors.length === 0) {
      completeStats.colors = [
        {
          id: 'T0',
          name: 'Default Color',
          hexColor: '#888888',
          firstLayer: 0,
          lastLayer: completeStats.totalLayers - 1,
          layerCount: completeStats.totalLayers,
          usagePercentage: 100,
        },
      ];
    }

    this.logger.info('Full parse complete', {
      parseTime: `${parseTime}ms`,
      totalLayers: completeStats.totalLayers,
      uniqueColors: completeStats.colors.length,
    });

    return completeStats;
  }
}