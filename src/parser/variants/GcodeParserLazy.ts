import { GcodeStats, ToolChange, LayerColorInfo } from '../../types';
import { Color } from '../../domain/models/Color';
import { Logger } from '../../utils/logger';
import { BrowserFileReader } from '../../utils/fileReader';

interface LazyParseResult {
  basicStats: {
    fileName: string;
    fileSize: number;
    totalLayers: number;
    uniqueTools: Set<string>;
    hasFilamentChanges: boolean;
  };
  getFullStats: () => Promise<GcodeStats>;
}

export class GcodeParserLazy {
  private logger: Logger;
  private onProgress?: (progress: number, message: string) => void;

  constructor(logger?: Logger, onProgress?: (progress: number, message: string) => void) {
    this.logger = logger || new Logger('GcodeParserLazy');
    this.onProgress = onProgress;
  }

  async parse(file: File): Promise<GcodeStats> {
    // For benchmark compatibility, we'll do the full parse
    // In a real implementation, this would return LazyParseResult
    const result = await this.lazyParse(file);
    return await result.getFullStats();
  }

  async lazyParse(file: File): Promise<LazyParseResult> {
    const startTime = Date.now();
    this.logger.info(`Starting lazy G-code parse for ${file.name}`);

    if (this.onProgress) {
      this.onProgress(5, 'Quick scan starting...');
    }

    // Basic info available immediately
    const basicStats = {
      fileName: file.name,
      fileSize: file.size,
      totalLayers: 0,
      uniqueTools: new Set<string>(['T0']),
      hasFilamentChanges: false,
    };

    // Quick scan - only look for essential info
    const quickScanResult = await this.quickScan(file);
    basicStats.totalLayers = quickScanResult.maxLayer + 1;
    basicStats.uniqueTools = quickScanResult.tools;
    basicStats.hasFilamentChanges = quickScanResult.hasM600;

    const quickScanTime = Date.now() - startTime;
    this.logger.info(`Quick scan completed in ${quickScanTime}ms`);

    if (this.onProgress) {
      this.onProgress(100, 'Quick scan complete!');
    }

    // Return lazy result with deferred full parsing
    return {
      basicStats,
      getFullStats: async () => {
        this.logger.info('Full parse requested, processing...');
        if (this.onProgress) {
          this.onProgress(0, 'Starting full analysis...');
        }
        return await this.fullParse(file, quickScanResult);
      },
    };
  }

  private async quickScan(file: File): Promise<{
    maxLayer: number;
    tools: Set<string>;
    hasM600: boolean;
    colorDefs?: string[];
    slicerInfo?: { software: string; version: string };
  }> {
    const reader = new BrowserFileReader(file);
    let maxLayer = 0;
    const tools = new Set<string>(['T0']);
    let hasM600 = false;
    let colorDefs: string[] | undefined;
    let slicerInfo: { software: string; version: string } | undefined;
    let linesScanned = 0;
    const maxLinesToScan = 10000; // Only scan first 10k lines for quick info

    for await (const line of reader.readLines()) {
      linesScanned++;

      // Stop after scanning enough lines
      if (linesScanned > maxLinesToScan) {
        this.logger.info(`Quick scan stopped after ${maxLinesToScan} lines`);
        break;
      }

      const trimmed = line.trim();

      // Skip empty lines
      if (!trimmed) continue;

      // Check for tool changes (quick check) - only T0 through T7
      if (trimmed[0] === 'T' && trimmed.length >= 2) {
        const secondChar = trimmed[1];
        if (secondChar >= '0' && secondChar <= '7') {
          const toolCmd = trimmed.split(' ')[0].toUpperCase();
          if (toolCmd.match(/^T[0-7]$/)) {
            tools.add(toolCmd);
          }
        }
      }

      // Check for M600
      else if (trimmed.startsWith('M600')) {
        hasM600 = true;
      }

      // Check comments for important info
      else if (trimmed[0] === ';') {
        // Layer detection
        if (trimmed.includes('layer')) {
          const layerMatch = trimmed.match(/layer\s*(?:#|num\/total_layer_count:)?\s*(\d+)/i);
          if (layerMatch) {
            const layer = parseInt(layerMatch[1]);
            if (layer > maxLayer) maxLayer = layer;
          }
        }

        // Color definitions
        else if (
          (trimmed.includes('extruder_colour') || trimmed.includes('filament_colour')) &&
          !colorDefs
        ) {
          const parts = trimmed.split('=');
          if (parts.length > 1) {
            colorDefs = parts[1].split(';').map((c) => c.trim());
          }
        }

        // Slicer info
        else if (trimmed.includes('generated by') && !slicerInfo) {
          const match = trimmed.match(/generated by\s+(.+?)\s+(.+)/);
          if (match) {
            slicerInfo = { software: match[1], version: match[2] };
          }
        }
      }

      // Progress update
      if (this.onProgress && linesScanned % 1000 === 0) {
        const progress = Math.min((linesScanned / maxLinesToScan) * 90, 90);
        this.onProgress(progress, `Quick scanning... ${linesScanned} lines`);
      }
    }

    return { maxLayer, tools, hasM600, colorDefs, slicerInfo };
  }

  private async fullParse(
    file: File,
    quickScanResult: {
      maxLayer: number;
      tools: Set<string>;
      hasM600: boolean;
      colorDefs?: string[];
      slicerInfo?: { software: string; version: string };
    }
  ): Promise<GcodeStats> {
    const startTime = Date.now();
    const stats: Partial<GcodeStats> = {
      fileName: file.name,
      fileSize: file.size,
      totalLayers: 1,
      totalHeight: 0,
      toolChanges: [],
      layerColorMap: new Map(),
      parserWarnings: [],
      colors: [],
      slicerInfo: quickScanResult.slicerInfo,
    };

    if (quickScanResult.slicerInfo && quickScanResult.colorDefs) {
      stats.slicerInfo!.colorDefinitions = quickScanResult.colorDefs;
    }

    let currentLayer = 0;
    let maxLayerSeen = 0;
    let currentZ = 0;
    let currentTool = 'T0';
    const activeTools = new Set<string>(['T0']); // Track all tools that have been used
    const toolChanges: ToolChange[] = [];
    const layerColorMap: Map<number, string[]> = new Map();
    const layerDetails: Map<number, LayerColorInfo> = new Map();
    const colorFirstSeen: Map<string, number> = new Map();
    const colorLastSeen: Map<string, number> = new Map();
    let layerToolChanges: ToolChange[] = [];
    let lineNumber = 0;

    // Initialize
    layerColorMap.set(0, [currentTool]);
    colorFirstSeen.set(currentTool, 0);
    colorLastSeen.set(currentTool, 0);

    const reader = new BrowserFileReader(file);
    const estimatedLines = Math.ceil(file.size / 24);
    const progressInterval = Math.max(Math.floor(estimatedLines / 100), 1000);

    if (this.onProgress) {
      this.onProgress(20, 'Full parsing in progress...');
    }

    for await (const line of reader.readLines()) {
      lineNumber++;
      const trimmed = line.trim();

      if (!trimmed) continue;

      // Comments
      if (trimmed[0] === ';') {
        // Layer changes
        if (trimmed.includes('layer')) {
          const layerMatch = trimmed.match(/layer\s*(?:#|num\/total_layer_count:)?\s*(\d+)/i);
          if (layerMatch) {
            const newLayer = parseInt(layerMatch[1]);
            if (newLayer !== currentLayer) {
              // Finalize previous layer
              if (layerToolChanges.length > 0 || currentLayer === 0) {
                this.finalizeLayer(
                  currentLayer,
                  layerColorMap,
                  layerDetails,
                  layerToolChanges,
                  currentTool
                );
              }

              // Start new layer
              currentLayer = newLayer;
              if (newLayer > maxLayerSeen) {
                maxLayerSeen = newLayer;
              }

              // Initialize new layer with ALL active tools (color persistence)
              const layerColors = layerColorMap.get(currentLayer) || [];
              for (const tool of activeTools) {
                if (!layerColors.includes(tool)) {
                  layerColors.push(tool);
                }
                // Update color last seen
                colorLastSeen.set(tool, currentLayer);
              }
              layerColorMap.set(currentLayer, layerColors);

              layerToolChanges = [];
            }
          }
        }

        // Print time
        else if (trimmed.includes('estimated') && trimmed.includes('time')) {
          const timeMatch = trimmed.match(/(\d+)h\s*(\d+)m\s*(\d+)s/);
          if (timeMatch) {
            const hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            const seconds = parseInt(timeMatch[3]);
            stats.printTime = `${hours}h ${minutes}m ${seconds}s`;
            stats.estimatedPrintTime = hours * 3600 + minutes * 60 + seconds;
          }
        }

        // Filament usage
        else if (trimmed.includes('filament used [g]')) {
          const parts = trimmed.split('=');
          if (parts.length > 1) {
            const weights = parts[1].split(',').map((w) => parseFloat(w.trim()));
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);

            stats.filamentUsageStats = {
              total: Math.round(totalWeight * 100) / 100,
              model: 0,
              support: 0,
              flushed: 0,
              tower: 0,
            };

            stats.filamentEstimates = [];
            weights.forEach((weight, index) => {
              if (weight > 0) {
                stats.filamentEstimates!.push({
                  colorId: `T${index}`,
                  length: 0,
                  weight: weight,
                });
              }
            });
          }
        }
      }

      // Commands
      else {
        const command = trimmed.split(' ')[0].toUpperCase();

        // Move commands
        if (command === 'G0' || command === 'G1') {
          const zMatch = trimmed.match(/Z([-+]?\d*\.?\d+)/);
          if (zMatch) {
            const newZ = parseFloat(zMatch[1]);
            if (!isNaN(newZ) && newZ > currentZ) {
              currentZ = newZ;
              if (!stats.totalHeight || newZ > stats.totalHeight) {
                stats.totalHeight = newZ;
              }
            }
          }
        }

        // Tool changes - only T0 through T7
        else if (
          command.length === 2 &&
          command[0] === 'T' &&
          command[1] >= '0' &&
          command[1] <= '7'
        ) {
          if (command !== currentTool) {
            const toolChange: ToolChange = {
              fromTool: currentTool,
              toTool: command,
              layer: currentLayer,
              lineNumber: lineNumber,
              zHeight: currentZ,
            };

            toolChanges.push(toolChange);
            layerToolChanges.push(toolChange);
            currentTool = command;

            // Track this tool as active (used in the print)
            activeTools.add(command);

            // Add color to current layer's array
            const layerColors = layerColorMap.get(currentLayer) || [];
            if (!layerColors.includes(command)) {
              layerColors.push(command);
            }
            layerColorMap.set(currentLayer, layerColors);

            // Track color usage
            if (!colorFirstSeen.has(command)) {
              colorFirstSeen.set(command, currentLayer);
            }
            colorLastSeen.set(command, currentLayer);
          }
        }

        // Filament change
        else if (command === 'M600') {
          stats.parserWarnings?.push(
            `M600 filament change at layer ${currentLayer} (line ${lineNumber})`
          );
        }
      }

      // Progress
      if (this.onProgress && lineNumber % progressInterval === 0) {
        const progressPercent = (lineNumber / estimatedLines) * 60;
        const totalProgress = Math.min(20 + progressPercent, 80);
        this.onProgress(
          totalProgress,
          `Full parse: ${Math.round((lineNumber / estimatedLines) * 100)}%`
        );
      }
    }

    if (this.onProgress) {
      this.onProgress(85, 'Calculating statistics...');
    }

    // Finalize last layer
    if (layerToolChanges.length > 0 || currentLayer > 0) {
      this.finalizeLayer(currentLayer, layerColorMap, layerDetails, layerToolChanges, currentTool);
    }

    stats.totalLayers = maxLayerSeen + 1;
    stats.totalHeight = currentZ;
    stats.toolChanges = toolChanges;
    stats.layerColorMap = layerColorMap;
    stats.layerDetails = Array.from(layerDetails.values()).sort((a, b) => a.layer - b.layer);

    // Calculate colors and usage ranges
    const uniqueColors = new Set<string>();
    layerColorMap.forEach((colors) => {
      colors.forEach((color) => uniqueColors.add(color));
    });

    stats.colors = Array.from(uniqueColors)
      .sort((a, b) => a.localeCompare(b)) // Sort colors by ID
      .map((colorId) => {
        // Build set of layers where this color is used
        const layersUsed = new Set<number>();
        layerColorMap.forEach((colors, layer) => {
          if (colors.includes(colorId)) {
            layersUsed.add(layer);
          }
        });

        return new Color({
          id: colorId,
          name: colorId,
          hexValue: this.getColorHex(colorId, quickScanResult.colorDefs),
          firstLayer: colorFirstSeen.get(colorId)!,
          lastLayer: colorLastSeen.get(colorId)!,
          layersUsed: layersUsed,
          totalLayers: stats.totalLayers,
        });
      });

    stats.colorUsageRanges = this.calculateColorRanges(layerColorMap);

    // Calculate parse time
    stats.parseTime = Date.now() - startTime;

    if (this.onProgress) {
      this.onProgress(100, 'Parse complete!');
    }

    this.logger.info(`Full parse completed in ${stats.parseTime}ms`);
    return stats as GcodeStats;
  }

  private finalizeLayer(
    layer: number,
    layerColorMap: Map<number, string[]>,
    layerDetails: Map<number, LayerColorInfo>,
    layerToolChanges: ToolChange[],
    currentTool: string
  ): void {
    const layerColors = layerColorMap.get(layer) || [currentTool];

    // Ensure layer has at least the current tool
    if (layerColors.length === 0) {
      layerColors.push(currentTool);
      layerColorMap.set(layer, layerColors);
    }

    // Calculate primary color (most used - for now, we'll use the first color)
    // In a more sophisticated implementation, we'd track actual usage
    const primaryColor = layerColors[0];

    layerDetails.set(layer, {
      layer,
      colors: [...layerColors],
      primaryColor,
      toolChangeCount: layerToolChanges.length,
      toolChangesInLayer: [...layerToolChanges],
    });
  }

  private getColorHex(colorId: string, colorDefs?: string[]): string {
    if (!colorDefs) return '#808080'; // Default gray

    const toolIndex = parseInt(colorId.substring(1));
    if (toolIndex >= 0 && toolIndex < colorDefs.length) {
      const color = colorDefs[toolIndex];
      // Ensure color is valid hex format
      if (color && color.length > 0) {
        // Remove any # prefix if present
        const cleanColor = color.startsWith('#') ? color.substring(1) : color;
        // Validate hex format (6 characters, 0-9 A-F)
        if (/^[0-9A-Fa-f]{6}$/.test(cleanColor)) {
          return `#${cleanColor.toUpperCase()}`;
        }
      }
    }

    return '#808080';
  }

  private calculateColorRanges(layerColorMap: Map<number, string[]>): any[] {
    const colorRanges: any[] = [];
    const colorLayerMap = new Map<string, number[]>();

    // Build map of which layers each color appears in
    layerColorMap.forEach((colors, layer) => {
      colors.forEach((color) => {
        if (!colorLayerMap.has(color)) {
          colorLayerMap.set(color, []);
        }
        colorLayerMap.get(color)!.push(layer);
      });
    });

    // Calculate ranges for each color
    colorLayerMap.forEach((layers, colorId) => {
      layers.sort((a, b) => a - b);

      let start = layers[0];
      let end = start;

      for (let i = 1; i < layers.length; i++) {
        if (layers[i] === end + 1) {
          end = layers[i];
        } else {
          colorRanges.push({
            colorId,
            startLayer: start,
            endLayer: end,
            continuous: true,
          });
          start = layers[i];
          end = start;
        }
      }

      colorRanges.push({
        colorId,
        startLayer: start,
        endLayer: end,
        continuous: true,
      });
    });

    return colorRanges;
  }
}
