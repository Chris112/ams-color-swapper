import { GcodeStats } from '../../types/gcode';
import { ToolChange } from '../../types/tool';
import { LayerColorInfo } from '../../types/layer';
import { Logger } from '../../utils/logger';
import { BrowserFileReader } from '../../utils/fileReader';
import { gcodeToInternalLayer, detectGcodeNumberingScheme } from '../../utils/layerHelpers';

interface LazyParseResult {
  basicStats: {
    fileName: string;
    fileSize: number;
    totalLayers: number;
    uniqueTools: Set<string>;
    hasFilamentChanges: boolean;
  };
  getFullStats: () => Promise<GcodeStats>;
}

export class GcodeParserLazy {
  private logger: Logger;
  private onProgress?: (progress: number, message: string) => void;

  constructor(logger?: Logger, onProgress?: (progress: number, message: string) => void) {
    this.logger = logger || new Logger('GcodeParserLazy');
    this.onProgress = onProgress;
  }

  async parse(file: File): Promise<GcodeStats> {
    // For benchmark compatibility, we'll do the full parse
    // In a real implementation, this would return LazyParseResult
    const result = await this.lazyParse(file);
    return await result.getFullStats();
  }

  async lazyParse(file: File): Promise<LazyParseResult> {
    const startTime = Date.now();
    this.logger.info(`Starting lazy G-code parse for ${file.name}`);

    if (this.onProgress) {
      this.onProgress(5, 'Quick scan starting...');
    }

    // Basic info available immediately
    const basicStats = {
      fileName: file.name,
      fileSize: file.size,
      totalLayers: 0,
      uniqueTools: new Set<string>(['T0']),
      hasFilamentChanges: false,
    };

    // Quick scan - only look for essential info
    const quickScanResult = await this.quickScan(file);
    basicStats.totalLayers = quickScanResult.maxLayer + 1;
    basicStats.uniqueTools = quickScanResult.tools;
    basicStats.hasFilamentChanges = quickScanResult.hasM600;

    const quickScanTime = Date.now() - startTime;
    this.logger.info(`Quick scan completed in ${quickScanTime}ms`);

    if (this.onProgress) {
      this.onProgress(100, 'Quick scan complete!');
    }

    // Return lazy result with deferred full parsing
    return {
      basicStats,
      getFullStats: async () => {
        this.logger.info('Full parse requested, processing...');
        if (this.onProgress) {
          this.onProgress(0, 'Starting full analysis...');
        }
        return await this.fullParse(file, quickScanResult);
      },
    };
  }

  private async quickScan(file: File): Promise<{
    maxLayer: number;
    tools: Set<string>;
    hasM600: boolean;
    colorDefs?: string[];
    slicerInfo?: { software: string; version: string };
  }> {
    const reader = new BrowserFileReader(file);
    let maxLayer = 0;
    const tools = new Set<string>(['T0']);
    let hasM600 = false;
    let colorDefs: string[] | undefined;
    let slicerInfo: { software: string; version: string } | undefined;
    let linesScanned = 0;
    const maxLinesToScan = 10000; // Only scan first 10k lines for quick info

    for await (const line of reader.readLines()) {
      linesScanned++;

      // Stop after scanning enough lines
      if (linesScanned > maxLinesToScan) {
        this.logger.info(`Quick scan stopped after ${maxLinesToScan} lines`);
        break;
      }

      const trimmed = line.trim();

      // Skip empty lines
      if (!trimmed) continue;

      // Check for tool changes (quick check) - only T0 through T7
      if (trimmed[0] === 'T' && trimmed.length >= 2) {
        const secondChar = trimmed[1];
        if (secondChar >= '0' && secondChar <= '7') {
          const toolCmd = trimmed.split(' ')[0].toUpperCase();
          if (toolCmd.match(/^T[0-7]$/)) {
            tools.add(toolCmd);
          }
        }
      }

      // Check for M600
      else if (trimmed.startsWith('M600')) {
        hasM600 = true;
      }

      // Check comments for important info
      else if (trimmed[0] === ';') {
        // Layer detection
        if (trimmed.includes('layer')) {
          const layerMatch = trimmed.match(/layer\s*(?:#|num\/total_layer_count:)?\s*(\d+)/i);
          if (layerMatch) {
            const layer = parseInt(layerMatch[1]);
            if (layer > maxLayer) maxLayer = layer;
          }
        }

        // Color definitions
        else if (
          (trimmed.includes('extruder_colour') || trimmed.includes('filament_colour')) &&
          !colorDefs
        ) {
          const parts = trimmed.split('=');
          if (parts.length > 1) {
            colorDefs = parts[1].split(';').map((c) => c.trim());
          }
        }

        // Slicer info
        else if (trimmed.includes('generated by') && !slicerInfo) {
          const match = trimmed.match(/generated by\s+(.+?)\s+(.+)/);
          if (match) {
            slicerInfo = { software: match[1], version: match[2] };
          }
        }
      }

      // Progress update
      if (this.onProgress && linesScanned % 1000 === 0) {
        const progress = Math.min((linesScanned / maxLinesToScan) * 90, 90);
        this.onProgress(progress, `Quick scanning... ${linesScanned} lines`);
      }
    }

    return { maxLayer, tools, hasM600, colorDefs, slicerInfo };
  }

  private async fullParse(
    file: File,
    quickScanResult: {
      maxLayer: number;
      tools: Set<string>;
      hasM600: boolean;
      colorDefs?: string[];
      slicerInfo?: { software: string; version: string };
    }
  ): Promise<GcodeStats> {
    const startTime = Date.now();
    const stats: Partial<GcodeStats> = {
      fileName: file.name,
      fileSize: file.size,
      totalLayers: 1,
      totalHeight: 0,
      toolChanges: [],
      layerColorMap: new Map(),
      parserWarnings: [],
      colors: [],
      slicerInfo: quickScanResult.slicerInfo,
    };

    if (quickScanResult.slicerInfo && quickScanResult.colorDefs) {
      stats.slicerInfo!.colorDefinitions = quickScanResult.colorDefs;
    }

    let currentLayer = 0; // Start with layer 0
    let maxLayerSeen = 0;
    let currentZ = 0;
    let currentTool = 'T0';
    const activeTools = new Set<string>(['T0']); // Track all tools that have been used
    const toolChanges: ToolChange[] = [];
    const layerColorMap: Map<number, string[]> = new Map();
    const layerDetails: Map<number, LayerColorInfo> = new Map();
    const colorFirstSeen: Map<string, number> = new Map();
    const colorLastSeen: Map<string, number> = new Map();
    let layerToolChanges: ToolChange[] = [];
    let lineNumber = 0;
    const gcodeLayers: number[] = []; // Track raw G-code layer numbers for scheme detection
    let isGcodeOneBased: boolean | null = null; // Will be determined during parsing

    // Initialize layer 0 with T0 (will be enhanced by layer detection if present)
    layerColorMap.set(0, [currentTool]);
    colorFirstSeen.set(currentTool, 0);
    colorLastSeen.set(currentTool, 0);

    const reader = new BrowserFileReader(file);
    const estimatedLines = Math.ceil(file.size / 24);
    const progressInterval = Math.max(Math.floor(estimatedLines / 100), 1000);

    if (this.onProgress) {
      this.onProgress(20, 'Full parsing in progress...');
    }

    for await (const line of reader.readLines()) {
      lineNumber++;
      const trimmed = line.trim();

      if (!trimmed) continue;

      // Comments
      if (trimmed[0] === ';') {
        // Handle various layer formats (using same logic as main parser)
        let layerMatch = null;

        // Bambu Lab format: "; layer num/total_layer_count: 1/197"
        if (trimmed.includes('layer num/total_layer_count:')) {
          layerMatch = trimmed.match(/layer num\/total_layer_count:\s*(\d+)/);
        }
        // Bambu Lab format: "; layer #2"
        else if (trimmed.includes('; layer #')) {
          layerMatch = trimmed.match(/; layer #(\d+)/);
        }
        // Standard formats
        else if (trimmed.includes('LAYER:') || trimmed.includes('layer ')) {
          layerMatch = trimmed.match(/(?:LAYER:|layer )\s*(\d+)/i);
        }

        if (layerMatch) {
          const gcodeLayer = parseInt(layerMatch[1]);

          // Track G-code layer numbers for numbering scheme detection
          gcodeLayers.push(gcodeLayer);

          // Detect numbering scheme if not already determined
          if (isGcodeOneBased === null && gcodeLayers.length >= 1) {
            isGcodeOneBased = detectGcodeNumberingScheme(gcodeLayers);
            this.logger.info(
              `Detected G-code numbering scheme: ${isGcodeOneBased ? '1-based' : '0-based'}`
            );
          }

          // Convert G-code layer to internal 0-based layer
          const internalLayer = gcodeToInternalLayer(gcodeLayer, isGcodeOneBased || false);

          if (internalLayer !== currentLayer) {
            // Finalize previous layer
            if (layerToolChanges.length > 0 || currentLayer >= 0) {
              this.finalizeLayer(
                currentLayer,
                layerColorMap,
                layerDetails,
                layerToolChanges,
                currentTool
              );
            }

            // Start new layer
            currentLayer = internalLayer;
            if (internalLayer > maxLayerSeen) {
              maxLayerSeen = internalLayer;
            }

            // Initialize new layer with ALL active tools (color persistence)
            const layerColors = layerColorMap.get(currentLayer) || [];
            for (const tool of activeTools) {
              if (!layerColors.includes(tool)) {
                layerColors.push(tool);
              }
              // Update color last seen
              colorLastSeen.set(tool, currentLayer);
            }
            layerColorMap.set(currentLayer, layerColors);

            layerToolChanges = [];
          }
        }

        // Print time
        else if (trimmed.includes('estimated') && trimmed.includes('time')) {
          const timeMatch = trimmed.match(/(\d+)h\s*(\d+)m\s*(\d+)s/);
          if (timeMatch) {
            const hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            const seconds = parseInt(timeMatch[3]);
            stats.printTime = `${hours}h ${minutes}m ${seconds}s`;
            stats.estimatedPrintTime = hours * 3600 + minutes * 60 + seconds;
          }
        }

        // Filament usage
        else if (trimmed.includes('filament used [g]')) {
          const parts = trimmed.split('=');
          if (parts.length > 1) {
            const weights = parts[1].split(',').map((w) => parseFloat(w.trim()));
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);

            stats.filamentUsageStats = {
              total: Math.round(totalWeight * 100) / 100,
              model: 0,
              support: 0,
              flushed: 0,
              tower: 0,
            };

            stats.filamentEstimates = [];
            weights.forEach((weight, index) => {
              if (weight > 0) {
                stats.filamentEstimates!.push({
                  colorId: `T${index}`,
                  length: 0,
                  weight: weight,
                });
              }
            });
          }
        }
      }

      // Commands
      else {
        const command = trimmed.split(' ')[0].toUpperCase();

        // Move commands
        if (command === 'G0' || command === 'G1') {
          const zMatch = trimmed.match(/Z([-+]?\d*\.?\d+)/);
          if (zMatch) {
            const newZ = parseFloat(zMatch[1]);
            if (!isNaN(newZ) && newZ > currentZ) {
              currentZ = newZ;
              if (!stats.totalHeight || newZ > stats.totalHeight) {
                stats.totalHeight = newZ;
              }
            }
          }
        }

        // Tool changes - only T0 through T7
        else if (
          command.length === 2 &&
          command[0] === 'T' &&
          command[1] >= '0' &&
          command[1] <= '7'
        ) {
          if (command !== currentTool) {
            const toolChange: ToolChange = {
              fromTool: currentTool,
              toTool: command,
              layer: currentLayer,
              lineNumber: lineNumber,
              zHeight: currentZ,
            };

            toolChanges.push(toolChange);
            layerToolChanges.push(toolChange);
            currentTool = command;

            // Track this tool as active (used in the print)
            activeTools.add(command);

            // Add color to current layer's array
            const layerColors = layerColorMap.get(currentLayer) || [];
            if (!layerColors.includes(command)) {
              layerColors.push(command);
            }
            layerColorMap.set(currentLayer, layerColors);

            // Track color usage
            if (!colorFirstSeen.has(command)) {
              colorFirstSeen.set(command, currentLayer);
            }
            colorLastSeen.set(command, currentLayer);
          }
        }

        // Filament change
        else if (command === 'M600') {
          stats.parserWarnings?.push(
            `M600 filament change at layer ${currentLayer} (line ${lineNumber})`
          );
        }
      }

      // Progress
      if (this.onProgress && lineNumber % progressInterval === 0) {
        const progressPercent = (lineNumber / estimatedLines) * 60;
        const totalProgress = Math.min(20 + progressPercent, 80);
        this.onProgress(
          totalProgress,
          `Full parse: ${Math.round((lineNumber / estimatedLines) * 100)}%`
        );
      }
    }

    if (this.onProgress) {
      this.onProgress(85, 'Calculating statistics...');
    }

    // Finalize last layer
    if (currentLayer >= 0) {
      this.finalizeLayer(currentLayer, layerColorMap, layerDetails, layerToolChanges, currentTool);
    }

    // Ensure T0 is present on all layers that were detected
    // If only layer 0 was used (no layer comments), T0 is already there
    // This is just a safety check to ensure consistency

    // Let calculateStatistics determine correct totalLayers based on indexing scheme
    // Don't override it here to maintain consistency with main parser

    const parseTime = Date.now() - startTime;

    // Import and calculate statistics like other parsers
    const { calculateStatistics } = await import('../statistics');
    const completeStats = await calculateStatistics(
      stats as GcodeStats,
      toolChanges,
      layerColorMap,
      colorFirstSeen,
      colorLastSeen,
      Array.from(layerDetails.values()),
      parseTime
    );

    if (this.onProgress) {
      this.onProgress(100, 'Parse complete!');
    }

    this.logger.info(`Full parse completed in ${parseTime}ms`);
    return completeStats;
  }

  private finalizeLayer(
    layer: number,
    layerColorMap: Map<number, string[]>,
    layerDetails: Map<number, LayerColorInfo>,
    layerToolChanges: ToolChange[],
    currentTool: string
  ): void {
    const layerColors = layerColorMap.get(layer) || [currentTool];

    // Ensure layer has at least the current tool
    if (layerColors.length === 0) {
      layerColors.push(currentTool);
      layerColorMap.set(layer, layerColors);
    }

    // Calculate primary color (most used - for now, we'll use the first color)
    // In a more sophisticated implementation, we'd track actual usage
    const primaryColor = layerColors[0];

    layerDetails.set(layer, {
      layer,
      colors: [...layerColors],
      primaryColor,
      toolChangeCount: layerToolChanges.length,
      toolChangesInLayer: [...layerToolChanges],
    });
  }
}
