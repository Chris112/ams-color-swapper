// Worker script for parallel G-code parsing
interface WorkerMessage {
  type: 'parse';
  chunk: string;
  chunkIndex: number;
  totalChunks: number;
}

interface WorkerResult {
  type: 'result';
  chunkIndex: number;
  data: {
    layers: Set<number>;
    tools: Set<string>;
    toolChanges: Array<{
      fromTool: string;
      toTool: string;
      layer: number;
      lineNumber: number;
    }>;
    maxZ: number;
    hasM600: boolean;
    colorDefs?: string[];
    slicerInfo?: { software: string; version: string };
    printTime?: string;
    filamentWeights?: number[];
    lineCount: number;
    layerColorMap: Array<[number, string]>;
  };
}

self.onmessage = (event: MessageEvent<WorkerMessage>) => {
  const { type, chunk, chunkIndex } = event.data;

  if (type === 'parse') {
    const result = parseChunk(chunk, chunkIndex);
    self.postMessage(result);
  }
};

function parseChunk(chunk: string, chunkIndex: number): WorkerResult {
  const lines = chunk.split('\n');
  const layers = new Set<number>();
  const tools = new Set<string>(['T0']);
  const toolChanges: WorkerResult['data']['toolChanges'] = [];
  const layerColorMap: Array<[number, string]> = [];
  
  let currentLayer = 0;
  let currentTool = 'T0';
  let maxZ = 0;
  let hasM600 = false;
  let colorDefs: string[] | undefined;
  let slicerInfo: { software: string; version: string } | undefined;
  let printTime: string | undefined;
  let filamentWeights: number[] | undefined;
  let localLineNumber = 0;

  for (const line of lines) {
    localLineNumber++;
    const trimmed = line.trim();

    if (!trimmed) continue;

    // Comments
    if (trimmed[0] === ';') {
      // Layer detection
      if (trimmed.includes('layer')) {
        let newLayer: number | null = null;

        // Bambu Lab formats
        let match = trimmed.match(/layer num\/total_layer_count:\s*(\d+)/);
        if (match) {
          newLayer = parseInt(match[1]);
        } else {
          match = trimmed.match(/; layer #(\d+)/);
          if (match) {
            newLayer = parseInt(match[1]);
          } else {
            match = trimmed.match(/LAYER:\s*(\d+)/);
            if (match) {
              newLayer = parseInt(match[1]);
            } else {
              match = trimmed.match(/layer\s+(\d+)/i);
              if (match) {
                newLayer = parseInt(match[1]);
              }
            }
          }
        }

        if (newLayer !== null && newLayer !== currentLayer) {
          currentLayer = newLayer;
          layers.add(currentLayer);
          layerColorMap.push([currentLayer, currentTool]);
        }
      }

      // Color definitions
      else if ((trimmed.includes('extruder_colour') || trimmed.includes('filament_colour')) && !colorDefs) {
        const parts = trimmed.split('=');
        if (parts.length > 1) {
          colorDefs = parts[1].split(';');
        }
      }

      // Slicer info
      else if (trimmed.includes('generated by') && !slicerInfo) {
        const match = trimmed.match(/generated by\s+(.+?)\s+(.+)/);
        if (match) {
          slicerInfo = { software: match[1], version: match[2] };
        }
      }

      // Print time
      else if (trimmed.includes('estimated') && trimmed.includes('time') && !printTime) {
        const match = trimmed.match(/(\d+)h\s*(\d+)m\s*(\d+)s/);
        if (match) {
          const hours = parseInt(match[1]);
          const minutes = parseInt(match[2]);
          const seconds = parseInt(match[3]);
          printTime = `${hours}h ${minutes}m ${seconds}s`;
        }
      }

      // Filament weights
      else if (trimmed.includes('filament used [g]') && !filamentWeights) {
        const parts = trimmed.split('=');
        if (parts.length > 1) {
          filamentWeights = parts[1].split(',').map((w) => parseFloat(w.trim()));
        }
      }
    }
    // Commands
    else {
      const command = trimmed.split(' ')[0].toUpperCase();

      // Move commands
      if (command === 'G0' || command === 'G1') {
        const match = trimmed.match(/Z([-+]?\d*\.?\d+)/);
        if (match) {
          const z = parseFloat(match[1]);
          if (!isNaN(z) && z > maxZ) {
            maxZ = z;
          }
        }
      }

      // Tool changes
      else if (command.length === 2 && command[0] === 'T' && command[1] >= '0' && command[1] <= '7') {
        tools.add(command);
        if (command !== currentTool) {
          toolChanges.push({
            fromTool: currentTool,
            toTool: command,
            layer: currentLayer,
            lineNumber: localLineNumber,
          });
          currentTool = command;
        }
      }

      // Filament change
      else if (command === 'M600') {
        hasM600 = true;
      }
    }
  }

  return {
    type: 'result',
    chunkIndex,
    data: {
      layers,
      tools,
      toolChanges,
      maxZ,
      hasM600,
      colorDefs,
      slicerInfo,
      printTime,
      filamentWeights,
      lineCount: localLineNumber,
      layerColorMap,
    },
  };
}