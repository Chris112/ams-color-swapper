import { GcodeStats } from '../../types/gcode';
import { ToolChange } from '../../types/tool';
import { LayerColorInfo } from '../../types/layer';
import { Logger } from '../../utils/logger';
import { BrowserFileReader } from '../../utils/fileReader';

// Pre-compiled regex patterns
const PATTERNS = {
  // Command patterns
  MOVE_COMMAND: /^G[01]\b/,
  TOOL_CHANGE: /^T[0-7]\b/,
  FILAMENT_CHANGE: /^M600\b/,

  // Z coordinate extraction
  Z_COORD: /Z([-+]?\d*\.?\d+)/,

  // Layer patterns
  LAYER_BAMBU_FULL: /layer num\/total_layer_count:\s*(\d+)\/\d+/,
  LAYER_BAMBU_HASH: /;\s*layer\s*#(\d+)/,
  LAYER_STANDARD: /LAYER:\s*(\d+)/,
  LAYER_GENERIC: /layer\s+(\d+)/i,

  // Color definitions
  COLOR_DEFS: /(?:extruder_colour|filament_colour)\s*=\s*(.+)/,

  // Slicer info
  SLICER_INFO: /generated by\s+(.+?)\s+(.+)/,

  // Time patterns
  PRINT_TIME: /(?:total estimated time:|estimated printing time).*?(\d+)h\s*(\d+)m\s*(\d+)s/,

  // Filament patterns
  FILAMENT_WEIGHT: /filament used\s*\[g\]\s*=\s*(.+)/,
  FILAMENT_DETAILED: /filament used\s*\[g\]\s*=\s*([\d.]+)\s*\(([\d.]+)\s*\+\s*([\d.]+)\)/,
  FILAMENT_LENGTH: /filament used.*?(\d+\.?\d*)\s*mm/,
  FILAMENT_COST: /filament cost\s*=\s*(.+)/,
  FLUSHED_MATERIAL: /flushed material\s*=\s*([\d.]+)/,
  WIPE_TOWER: /wipe tower\s*=\s*([\d.]+)/,
} as const;

export class GcodeParserRegex {
  private logger: Logger;
  private stats: Partial<GcodeStats>;
  private currentLayer: number = 0;
  private maxLayerSeen: number = 0;
  private currentZ: number = 0;
  private currentTool: string = 'T0';
  private activeTools: Set<string> = new Set(['T0']); // Track all tools that have been used
  private toolChanges: ToolChange[] = [];
  private layerColorMap: Map<number, string[]> = new Map();
  private layerDetails: Map<number, LayerColorInfo> = new Map();
  private layerToolChanges: ToolChange[] = [];
  private colorFirstSeen: Map<string, number> = new Map();
  private colorLastSeen: Map<string, number> = new Map();
  private lineNumber: number = 0;
  private startTime: number = 0;
  private onProgress?: (progress: number, message: string) => void;

  constructor(logger?: Logger, onProgress?: (progress: number, message: string) => void) {
    this.logger = logger || new Logger('GcodeParserRegex');
    this.onProgress = onProgress;
    this.stats = {
      toolChanges: [],
      layerColorMap: new Map(),
      layerDetails: [],
      parserWarnings: [],
      colors: [],
    };
  }

  async parse(file: File): Promise<GcodeStats> {
    this.startTime = Date.now();
    this.logger.info(`Starting regex-optimized G-code parse for ${file.name}`);

    if (this.onProgress) {
      this.onProgress(5, 'Reading file...');
    }

    this.stats.fileName = file.name;
    this.stats.fileSize = file.size;
    this.stats.totalLayers = 1;
    this.stats.totalHeight = 0;

    // Initialize layer 0
    this.initializeLayer(0);
    this.addColorToLayer(0, this.currentTool);
    this.updateColorSeen(this.currentTool, 0);

    const estimatedLines = Math.ceil(file.size / 24);
    this.logger.info(`Estimated lines: ${estimatedLines.toLocaleString()}`);

    const reader = new BrowserFileReader(file);

    if (this.onProgress) {
      this.onProgress(20, 'Parsing with regex patterns...');
    }

    await this.processLines(reader, estimatedLines);

    // Finalize the last layer
    if (this.currentLayer >= 0) {
      this.updateLayerDetails(this.currentLayer);
    }

    // Set total layers based on maxLayerSeen
    this.stats.totalLayers = this.maxLayerSeen + 1;

    const parseTime = Date.now() - this.startTime;
    this.logger.info(`Regex parse completed in ${parseTime}ms`);

    if (this.onProgress) {
      this.onProgress(85, 'Analyzing colors and calculating statistics...');
    }

    // Import and calculate statistics
    const { calculateStatistics } = await import('../statistics');
    const completeStats = await calculateStatistics(
      this.stats as GcodeStats,
      this.toolChanges,
      this.layerColorMap,
      this.colorFirstSeen,
      this.colorLastSeen,
      Array.from(this.layerDetails.values()),
      parseTime
    );

    if (this.onProgress) {
      this.onProgress(95, 'Finalizing analysis...');
    }

    // Load raw content for geometry parsing if needed
    if (!this.stats.rawContent) {
      if (this.onProgress) {
        this.onProgress(90, 'Loading content for geometry parsing...');
      }
      this.stats.rawContent = await file.text();
      completeStats.rawContent = this.stats.rawContent;
    }

    return completeStats;
  }

  private async processLines(reader: BrowserFileReader, totalLines: number): Promise<void> {
    const progressInterval = Math.max(Math.floor(totalLines / 100), 1000);

    for await (const line of reader.readLines()) {
      this.lineNumber++;
      this.parseLine(line.trim());

      if (this.onProgress && this.lineNumber % progressInterval === 0) {
        const progressPercent = (this.lineNumber / totalLines) * 60;
        const totalProgress = Math.min(20 + progressPercent, 80);
        const percentage = Math.min(Math.round((this.lineNumber / totalLines) * 100), 100);
        this.onProgress(
          totalProgress,
          `Regex parsing: ${percentage}% (${this.lineNumber.toLocaleString()}/${totalLines.toLocaleString()})`
        );
      }
    }

    if (this.onProgress) {
      this.onProgress(80, `Processed all ${totalLines.toLocaleString()} lines`);
    }
  }

  private parseLine(line: string): void {
    if (!line) return;

    // Handle comments first
    if (line[0] === ';') {
      this.parseComment(line);
      return;
    }

    // Extract command using regex for better performance
    const firstSpace = line.indexOf(' ');
    const command = firstSpace === -1 ? line : line.substring(0, firstSpace);

    // Check movement commands
    if (PATTERNS.MOVE_COMMAND.test(command)) {
      this.parseMove(line);
    }
    // Check tool changes
    else if (PATTERNS.TOOL_CHANGE.test(command)) {
      this.parseToolChange(command);
    }
    // Check filament change
    else if (PATTERNS.FILAMENT_CHANGE.test(command)) {
      this.parseFilamentChange(line);
    }
  }

  private parseComment(line: string) {
    // Check for layer changes first (most common)
    if (line.includes('layer')) {
      let match: RegExpMatchArray | null = null;
      let newLayer: number | null = null;

      // Try each pattern
      if ((match = line.match(PATTERNS.LAYER_BAMBU_FULL))) {
        newLayer = parseInt(match[1]);
      } else if ((match = line.match(PATTERNS.LAYER_BAMBU_HASH))) {
        newLayer = parseInt(match[1]);
      } else if ((match = line.match(PATTERNS.LAYER_STANDARD))) {
        newLayer = parseInt(match[1]);
      } else if ((match = line.match(PATTERNS.LAYER_GENERIC))) {
        newLayer = parseInt(match[1]);
      }

      if (newLayer !== null && newLayer !== this.currentLayer) {
        // Finalize previous layer details
        if (this.currentLayer >= 0) {
          this.updateLayerDetails(this.currentLayer);
        }

        // Reset layer tool changes for new layer
        this.layerToolChanges = [];

        this.currentLayer = newLayer;
        if (newLayer > this.maxLayerSeen) {
          this.maxLayerSeen = newLayer;
        }

        // Initialize the new layer
        this.initializeLayer(this.currentLayer);

        // Add only the currently active tool to this layer
        // Each layer should only have the color that's actually being used
        if (this.currentTool !== null) {
          this.addColorToLayer(this.currentLayer, this.currentTool);
          this.updateColorSeen(this.currentTool, this.currentLayer);
        }

        this.logger.silly(
          `Layer ${this.currentLayer} - Active tools: ${Array.from(this.activeTools).join(', ')}, Current: ${this.currentTool}`
        );
        return;
      }
    }

    // Extract color definitions
    let match: RegExpMatchArray | null;
    if ((match = line.match(PATTERNS.COLOR_DEFS))) {
      const colors = match[1].split(';').map((c) => c.trim());
      this.logger.info(`Found ${colors.length} color definitions`);
      if (!this.stats.slicerInfo) {
        this.stats.slicerInfo = { software: 'Unknown', version: 'Unknown' };
      }
      this.stats.slicerInfo.colorDefinitions = colors;
    }

    // Extract slicer info
    else if ((match = line.match(PATTERNS.SLICER_INFO))) {
      if (!this.stats.slicerInfo) {
        this.stats.slicerInfo = {
          software: match[1],
          version: match[2],
        };
      }
      this.logger.info(`Detected slicer: ${match[1]} v${match[2]}`);
    }

    // Extract print time
    else if ((match = line.match(PATTERNS.PRINT_TIME))) {
      const hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      const seconds = parseInt(match[3]);
      this.stats.printTime = `${hours}h ${minutes}m ${seconds}s`;
      this.stats.estimatedPrintTime = hours * 3600 + minutes * 60 + seconds;
      this.logger.info(`Print time: ${this.stats.printTime}`);
    }

    // Extract filament weight
    else if ((match = line.match(PATTERNS.FILAMENT_WEIGHT))) {
      const weights = match[1].split(',').map((w) => parseFloat(w.trim()));
      const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);

      if (!this.stats.filamentUsageStats) {
        this.stats.filamentUsageStats = {
          total: Math.round(totalWeight * 100) / 100,
          model: 0,
          support: 0,
          flushed: 0,
          tower: 0,
        };
      } else {
        this.stats.filamentUsageStats.total = Math.round(totalWeight * 100) / 100;
      }

      if (!this.stats.filamentEstimates) {
        this.stats.filamentEstimates = [];
      }

      weights.forEach((weight, index) => {
        if (weight > 0) {
          const toolId = `T${index}`;
          const existingEntry = this.stats.filamentEstimates!.find((e) => e.colorId === toolId);
          if (existingEntry) {
            existingEntry.weight = weight;
          } else {
            this.stats.filamentEstimates!.push({
              colorId: toolId,
              length: 0,
              weight: weight,
            });
          }
        }
      });

      this.logger.info(`Total filament: ${this.stats.filamentUsageStats.total}g`);
    }

    // Extract detailed filament usage
    else if ((match = line.match(PATTERNS.FILAMENT_DETAILED))) {
      if (!this.stats.filamentUsageStats) {
        this.stats.filamentUsageStats = {
          total: 0,
          model: 0,
          support: 0,
          flushed: 0,
          tower: 0,
        };
      }
      this.stats.filamentUsageStats.total = parseFloat(match[1]);
      this.stats.filamentUsageStats.model = parseFloat(match[2]);
      this.stats.filamentUsageStats.support = parseFloat(match[3]);
    }

    // Extract filament cost
    else if ((match = line.match(PATTERNS.FILAMENT_COST))) {
      const costs = match[1].split(',').map((c) => parseFloat(c.trim()));
      const totalCost = costs.reduce((sum, cost) => sum + cost, 0);
      this.stats.printCost = Math.round(totalCost * 100) / 100;
      this.logger.info(`Print cost: ${this.stats.printCost}`);
    }

    // Extract flushed material
    else if ((match = line.match(PATTERNS.FLUSHED_MATERIAL))) {
      if (!this.stats.filamentUsageStats) {
        this.stats.filamentUsageStats = {
          total: 0,
          model: 0,
          support: 0,
          flushed: 0,
          tower: 0,
        };
      }
      this.stats.filamentUsageStats.flushed = parseFloat(match[1]);
    }

    // Extract wipe tower
    else if ((match = line.match(PATTERNS.WIPE_TOWER))) {
      if (!this.stats.filamentUsageStats) {
        this.stats.filamentUsageStats = {
          total: 0,
          model: 0,
          support: 0,
          flushed: 0,
          tower: 0,
        };
      }
      this.stats.filamentUsageStats.tower = parseFloat(match[1]);
    }

    // Extract filament length
    else if ((match = line.match(PATTERNS.FILAMENT_LENGTH))) {
      if (!this.stats.filamentEstimates) {
        this.stats.filamentEstimates = [];
      }
      this.stats.filamentEstimates.push({
        colorId: this.currentTool,
        length: parseFloat(match[1]),
      });
    }
  }

  private parseMove(line: string) {
    const match = line.match(PATTERNS.Z_COORD);
    if (match) {
      const newZ = parseFloat(match[1]);
      if (!isNaN(newZ) && newZ > this.currentZ) {
        this.currentZ = newZ;
        if (!this.stats.totalHeight || newZ > this.stats.totalHeight) {
          this.stats.totalHeight = newZ;
        }
      }
    }
  }

  private parseFilamentChange(_line: string) {
    this.logger.warn(
      `Manual filament change detected at layer ${this.currentLayer}, line ${this.lineNumber}`
    );
    this.stats.parserWarnings?.push(
      `M600 filament change at layer ${this.currentLayer} (line ${this.lineNumber})`
    );
  }

  private parseToolChange(tool: string) {
    if (tool !== this.currentTool) {
      const change: ToolChange = {
        fromTool: this.currentTool,
        toTool: tool,
        layer: this.currentLayer,
        lineNumber: this.lineNumber,
        zHeight: this.currentZ,
      };

      this.toolChanges.push(change);
      this.layerToolChanges.push(change);
      this.logger.silly(`Tool change: ${this.currentTool} → ${tool} at layer ${this.currentLayer}`);

      this.currentTool = tool;

      // Track this tool as active (used in the print)
      this.activeTools.add(tool);

      // Add the new tool to the current layer's color list
      this.addColorToLayer(this.currentLayer, tool);
      this.updateColorSeen(tool, this.currentLayer);
    }
  }

  private updateColorSeen(tool: string, layer: number) {
    if (!this.colorFirstSeen.has(tool)) {
      this.colorFirstSeen.set(tool, layer);
    }
    this.colorLastSeen.set(tool, layer);
  }

  private initializeLayer(layer: number) {
    if (!this.layerColorMap.has(layer)) {
      this.layerColorMap.set(layer, []);
    }
    if (!this.layerDetails.has(layer)) {
      this.layerDetails.set(layer, {
        layer,
        colors: [],
        primaryColor: this.currentTool,
        toolChangeCount: 0,
        toolChangesInLayer: [],
      });
    }
  }

  private addColorToLayer(layer: number, tool: string) {
    const colors = this.layerColorMap.get(layer) || [];
    if (!colors.includes(tool)) {
      colors.push(tool);
      this.layerColorMap.set(layer, colors);

      const layerInfo = this.layerDetails.get(layer);
      if (layerInfo) {
        layerInfo.colors = [...colors];
        layerInfo.primaryColor = colors[0]; // First color is primary for now
      }
    }
  }

  private updateLayerDetails(layer: number) {
    const layerInfo = this.layerDetails.get(layer);
    if (layerInfo) {
      layerInfo.toolChangesInLayer = [...this.layerToolChanges];
      layerInfo.toolChangeCount = this.layerToolChanges.length;
      // Primary color is the most recent tool (last one used in layer)
      layerInfo.primaryColor = this.currentTool;
    }
  }
}
