import { describe, it, expect, beforeAll } from 'vitest';
import { GcodeParserOptimized } from '../gcodeParserOptimized';
import { GcodeStats } from '../../types';

// Mock file for browser testing
function createMockFile(content: string, name: string): File {
  const blob = new Blob([content], { type: 'text/plain' });
  const file = new File([blob], name, { type: 'text/plain' });

  // Add the text() method that returns a Promise<string>
  (file as any).text = async () => content;

  return file;
}

describe('GcodeParserOptimized - Client Side', () => {
  let parser: GcodeParserOptimized;
  let testFileContent: string;
  let stats: GcodeStats;

  beforeAll(async () => {
    // In a real test, we'd load the actual file content
    // For now, we'll create a simplified test case
    testFileContent = `; generated by OrcaSlicer 1.9.0
; total estimated time: 5h 41m 9s
; filament cost = 0.95, 1.11, 0.03, 0.36, 0.00, 0.00
; filament used [g] = 37.57, 43.70, 1.04, 14.22, 0.00, 0.00
; layer num/total_layer_count: 0/137
T0
G0 X100 Y100 Z0.2
; layer num/total_layer_count: 1/137
G1 X110 Y110 E1.0
T1
G1 X120 Y120 E2.0
; layer num/total_layer_count: 2/137
T2
G1 X130 Y130 E3.0
; layer num/total_layer_count: 3/137
T3
G1 X140 Y140 E4.0
; layer num/total_layer_count: 4/137
T0
G1 X150 Y150 E5.0`;

    const mockFile = createMockFile(testFileContent, 'test.gcode');
    parser = new GcodeParserOptimized();
    stats = await parser.parse(mockFile);
  });

  describe('Basic File Information', () => {
    it('should extract file name and size', () => {
      expect(stats.fileName).toBe('test.gcode');
      expect(stats.fileSize).toBe(testFileContent.length);
    });

    it('should detect slicer information', () => {
      expect(stats.slicerInfo).toBeDefined();
      expect(stats.slicerInfo?.software).toBe('OrcaSlicer');
      expect(stats.slicerInfo?.version).toBe('1.9.0');
    });

    it('should extract print time', () => {
      expect(stats.printTime).toBe('5h 41m 9s');
      expect(stats.estimatedPrintTime).toBe(20469); // 5*3600 + 41*60 + 9
    });
  });

  describe('Tool and Color Analysis', () => {
    it('should detect all tool changes', () => {
      expect(stats.toolChanges).toHaveLength(4);
      expect(stats.toolChanges![0]).toMatchObject({
        fromTool: 'T0',
        toTool: 'T1',
        layer: 1,
      });
    });

    it('should extract color information', () => {
      expect(stats.colors).toHaveLength(4);
      const colorIds = stats.colors!.map((c) => c.id);
      expect(colorIds).toContain('T0');
      expect(colorIds).toContain('T1');
      expect(colorIds).toContain('T2');
      expect(colorIds).toContain('T3');
    });

    it('should track color usage by layer', () => {
      // Layer 0 starts with T0
      expect(stats.layerColorMap!.get(0)).toBe('T0');
      // Layer 1 has T1 (tool change happens on this layer)
      expect(stats.layerColorMap!.get(1)).toBe('T1');
      // Layer 2 has T2
      expect(stats.layerColorMap!.get(2)).toBe('T2');
      // Layer 3 has T3
      expect(stats.layerColorMap!.get(3)).toBe('T3');
      // Layer 4 has T0 again
      expect(stats.layerColorMap!.get(4)).toBe('T0');
    });
  });

  describe('Filament Usage', () => {
    it('should extract filament weights', () => {
      expect(stats.filamentUsageStats).toBeDefined();
      expect(stats.filamentUsageStats!.total).toBeCloseTo(96.53, 2);
    });

    it('should extract filament cost', () => {
      expect(stats.printCost).toBeCloseTo(2.45, 2);
    });

    it('should parse per-color filament usage', () => {
      expect(stats.filamentEstimates).toBeDefined();
      expect(stats.filamentEstimates!).toHaveLength(4); // Only colors with non-zero weight

      const t0Estimate = stats.filamentEstimates!.find((e) => e.colorId === 'T0');
      expect(t0Estimate).toBeDefined();
      expect(t0Estimate!.weight).toBe(37.57);
    });
  });

  describe('Parsing Edge Cases', () => {
    it('should handle empty files', async () => {
      const emptyFile = createMockFile('', 'empty.gcode');
      const emptyStats = await parser.parse(emptyFile);

      expect(emptyStats.colors).toHaveLength(1);
      expect(emptyStats.colors![0].id).toBe('T0');
      expect(emptyStats.totalLayers).toBe(1);
    });

    it('should handle files with only comments', async () => {
      const commentFile = createMockFile(
        '; This is a comment\n; Another comment',
        'comments.gcode'
      );
      const commentStats = await parser.parse(commentFile);

      expect(commentStats.toolChanges).toHaveLength(0);
      expect(commentStats.colors).toHaveLength(1);
    });
  });
});
