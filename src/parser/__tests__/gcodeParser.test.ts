import { describe, it, expect, beforeAll } from 'vitest';
import { GcodeParser } from '../gcodeParser';
import { GcodeStats } from '../../types';

// Mock file for browser testing
function createMockFile(content: string, name: string): File {
  const blob = new Blob([content], { type: 'text/plain' });
  const file = new File([blob], name, { type: 'text/plain' });

  // Add the text() method that returns a Promise<string>
  (file as any).text = async () => content;

  return file;
}

describe('GcodeParser - Client Side', () => {
  let parser: GcodeParser;
  let testFileContent: string;
  let stats: GcodeStats;

  beforeAll(async () => {
    // In a real test, we'd load the actual file content
    // For now, we'll create a simplified test case
    testFileContent = `; generated by OrcaSlicer 1.9.0
; total estimated time: 5h 41m 9s
; filament cost = 0.95, 1.11, 0.03, 0.36, 0.00, 0.00
; filament used [g] = 37.57, 43.70, 1.04, 14.22, 0.00, 0.00
; layer num/total_layer_count: 0/137
T0
G0 X100 Y100 Z0.2
; layer num/total_layer_count: 1/137
G1 X110 Y110 E1.0
T1
G1 X120 Y120 E2.0
; layer num/total_layer_count: 2/137
T2
G1 X130 Y130 E3.0
; layer num/total_layer_count: 3/137
T3
G1 X140 Y140 E4.0
; layer num/total_layer_count: 4/137
T0
G1 X150 Y150 E5.0`;

    const mockFile = createMockFile(testFileContent, 'test.gcode');
    parser = new GcodeParser();
    stats = await parser.parse(mockFile);
  });

  describe('Basic File Information', () => {
    it('should extract file name correctly', () => {
      expect(stats.fileName).toBe('test.gcode');
    });

    it('should detect slicer info', () => {
      expect(stats.slicerInfo?.software).toBe('OrcaSlicer');
      expect(stats.slicerInfo?.version).toBe('1.9.0');
    });

    it('should extract print time correctly', () => {
      expect(stats.printTime).toBe('5h 41m 9s');
    });

    it('should extract print cost correctly', () => {
      expect(stats.printCost).toBe(2.45);
    });

    it('should extract filament usage', () => {
      expect(stats.filamentUsageStats?.total).toBeCloseTo(96.53, 1);
    });
  });

  describe('Color Detection', () => {
    it('should detect all used colors', () => {
      expect(stats.colors.length).toBe(4);
    });

    it('should have correct color IDs', () => {
      const colorIds = stats.colors.map((c) => c.id).sort();
      expect(colorIds).toEqual(['T0', 'T1', 'T2', 'T3']);
    });

    it('should track tool changes', () => {
      expect(stats.toolChanges.length).toBe(4); // T0->T1, T1->T2, T2->T3, T3->T0
    });
  });

  describe('Layer Processing', () => {
    it('should count layers correctly', () => {
      expect(stats.totalLayers).toBeGreaterThanOrEqual(4);
    });

    it('should map colors to layers with persistence', () => {
      // With the color persistence fix, all active tools appear on every layer after introduction
      // Layer 0: Only T0 (starting tool)
      expect(stats.layerColorMap.get(0)).toEqual(['T0']);

      // Layer 1: T0 + T1 (T1 introduced via tool change)
      expect(stats.layerColorMap.get(1)).toContain('T0');
      expect(stats.layerColorMap.get(1)).toContain('T1');

      // Layer 2: T0 + T1 + T2 (T2 introduced, all previous tools persist)
      expect(stats.layerColorMap.get(2)).toContain('T0');
      expect(stats.layerColorMap.get(2)).toContain('T1');
      expect(stats.layerColorMap.get(2)).toContain('T2');

      // Layer 3: T0 + T1 + T2 + T3 (T3 introduced, all previous tools persist)
      expect(stats.layerColorMap.get(3)).toContain('T0');
      expect(stats.layerColorMap.get(3)).toContain('T1');
      expect(stats.layerColorMap.get(3)).toContain('T2');
      expect(stats.layerColorMap.get(3)).toContain('T3');

      // Layer 4: All tools still active (T0, T1, T2, T3)
      expect(stats.layerColorMap.get(4)).toContain('T0');
      expect(stats.layerColorMap.get(4)).toContain('T1');
      expect(stats.layerColorMap.get(4)).toContain('T2');
      expect(stats.layerColorMap.get(4)).toContain('T3');
    });

    it('should track multiple colors per layer with cumulative persistence', () => {
      // With persistence fix, each layer accumulates more colors as tools are introduced

      // Layer 0: Only T0
      expect(stats.layerColorMap.get(0)?.length).toBe(1);

      // Layer 1: T0 + T1 (2 colors)
      const layer1Colors = stats.layerColorMap.get(1);
      expect(layer1Colors).toBeDefined();
      expect(layer1Colors?.length).toBe(2);
      expect(layer1Colors).toContain('T0');
      expect(layer1Colors).toContain('T1');

      // Layer 2: T0 + T1 + T2 (3 colors)
      expect(stats.layerColorMap.get(2)?.length).toBe(3);

      // Layer 3: T0 + T1 + T2 + T3 (4 colors)
      expect(stats.layerColorMap.get(3)?.length).toBe(4);

      // Layer 4: Still all 4 colors
      expect(stats.layerColorMap.get(4)?.length).toBe(4);
    });

    it('should provide layer details with tool changes', () => {
      // Layer details should track tool changes within layers
      expect(stats.layerDetails).toBeDefined();
      expect(stats.layerDetails?.length).toBeGreaterThan(0);

      // Find layer 1 which has a tool change
      const layer1Detail = stats.layerDetails?.find((ld) => ld.layer === 1);
      expect(layer1Detail).toBeDefined();
      expect(layer1Detail?.toolChangeCount).toBeGreaterThan(0);
      expect(layer1Detail?.colors.length).toBeGreaterThan(1);
    });
  });
});

describe('GcodeParser - Browser File Reading', () => {
  it('should handle large files with streaming', async () => {
    // Create a large mock file (>1MB)
    const largeContent = 'G1 X10 Y10 E1.0\n'.repeat(65000);
    const largeFile = createMockFile(largeContent, 'large.gcode');

    const parser = new GcodeParser();
    const stats = await parser.parse(largeFile);

    expect(stats.fileName).toBe('large.gcode');
    expect(stats.fileSize).toBeGreaterThan(1000000);
  });

  it('should handle empty files gracefully', async () => {
    const emptyFile = createMockFile('', 'empty.gcode');
    const parser = new GcodeParser();
    const stats = await parser.parse(emptyFile);

    expect(stats.fileName).toBe('empty.gcode');
    expect(stats.colors.length).toBe(1); // Default T0
    expect(stats.toolChanges.length).toBe(0);
  });

  it('should handle files with only comments', async () => {
    const commentFile = createMockFile('; Just comments\n; No actual G-code', 'comments.gcode');
    const parser = new GcodeParser();
    const stats = await parser.parse(commentFile);

    expect(stats.totalLayers).toBe(1);
    expect(stats.colors.length).toBe(1); // Default T0
  });
});
